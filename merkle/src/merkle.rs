use hash::{Hashable, Algorithm};
use merkle_hash::MerkleHasher;
use std::hash::Hasher;

/// Merkle Tree.
///
/// All leafs and nodes are stored as linear array (vec).
/// A linear array was chosen as opposed to an actual tree structure since it uses
/// about half as much memory.  The following describes a merkle tree and how it
/// is stored in a linear array.
///
/// A merkle tree is a tree in which every non-leaf node is the hash of its
/// children nodes.  A diagram depicting how this works for bitcoin transactions
/// where h(x) is a double sha256 follows:
///
/// ```text
///         root = h1234 = h(h12 + h34)
///        /                           \
///  h12 = h(h1 + h2)            h34 = h(h3 + h4)
///   /            \              /            \
/// h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
/// ```
///
/// The above stored as a linear array is as follows:
///
/// ```text
///     [h1 h2 h3 h4 h12 h34 root]
/// ```
///
/// As the above shows, the merkle root is always the last element in the array.
///
/// The number of inputs is not always a power of two which results in a
/// balanced tree structure as above.  In that case, parent nodes with no
/// children are also zero and parent nodes with only a single left node
/// are calculated by concatenating the left node with itself before hashing.
/// Since this function uses nodes that are pointers to the hashes, empty nodes
/// will be nil.
///
/// TODO: From<> trait impl?
/// TODO: FromIter<> trait impl?
/// TODO: Index<t>
/// TODO: IntoIter
/// TODO: Ord, Eq
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct MerkleTree<T: AsRef<[u8]> + Sized + Ord + Clone + Default, A: Algorithm<T>> {
    data: Vec<T>,
    olen: usize,
    leafs: usize,
    height: usize,
    alg: A,
}

impl<T: AsRef<[u8]> + Sized + Ord + Clone + Default, A: Algorithm<T> + Hasher> MerkleTree<T, A> {
    /// Creates a new merkle from a sequence of hashes.
    pub fn new(data: &[T], alg: A) -> MerkleTree<T, A> {
        Self::from_hash(data, alg)
    }

    /// Creates a new merkle from a sequence of hashes.
    pub fn from_hash(data: &[T], alg: A) -> MerkleTree<T, A> {
        debug_assert_ne!(data.len(), 0);

        let pow = Self::next_pow2(data.len());
        let size = 2 * pow - 1;

        let mut mt: MerkleTree<T, A> = MerkleTree {
            data: Vec::with_capacity(size),
            olen: data.len(),
            leafs: pow,
            height: 1+pow.trailing_zeros() as usize,
            alg,
        };

        // Compute data leafs
        for h in data {
            mt.data.push(mt.alg.leaf(h.clone()))
        }

        mt.build();
        mt
    }

    /// Creates a new merkle tree hashable objects.
    /// TODO: reuse FromIter impl and map..collect
    pub fn from_data<U: Hashable<A>>(data: &[U], alg: A) -> MerkleTree<T, A> {
        debug_assert_ne!(data.len(), 0);

        let pow = Self::next_pow2(data.len());
        let size = 2 * pow - 1;

        let mut mt: MerkleTree<T, A> = MerkleTree {
            data: Vec::with_capacity(size),
            olen: data.len(),
            leafs: pow,
            height: 1+pow.trailing_zeros() as usize,
            alg,
        };

        // compute leafs
        for item in data {
            mt.alg.reset();
            item.hash(&mut mt.alg);

            let h = mt.alg.hash();
            mt.data.push(mt.alg.leaf(h))
        }

        mt.build();
        mt
    }

    fn build(&mut self) {
        let size = 2*self.leafs-1;
        let h0 = T::default();

        // not built yet
        debug_assert_ne!(size, self.data.len());

        // fill in
        for _ in 0..(size - self.olen) {
            self.data.push(h0.clone());
        }

        // build tree
        let mut i: usize = 0;
        let mut j: usize = (size + 1) / 2; // pow
        while i < size - 1 {
            if self.data[i] == h0 {
                // when there is no left child node, the parent is nil too.
                self.data[j] = h0.clone();
            } else if self.data[i + 1] == h0 {
                // when there is no right child, the parent is generated by
                // hashing the concatenation of the left child with itself.
                self.data[j] = self.alg.node(self.data[i].clone(), self.data[i].clone());
            } else {
                // the normal case sets the parent node to the double sha256
                // of the concatenation of the left and right children.
                self.data[j] = self.alg.node(
                    self.data[i].clone(),
                    self.data[i + 1].clone(),
                );
            }

            j += 1;
            i += 2;
        }
    }

    /// Returns merkle root
    pub fn root(&self) -> T {
        self.data[self.data.len() - 1].clone()
    }

    /// Returns original number of elements the tree was built upon.
    pub fn olen(&self) -> usize {
        self.olen
    }

    /// Returns number of elements in the tree.
    pub fn len(&self) -> usize {
        self.data.len()
    }

    /// Returns height of the tree
    pub fn height(&self) -> usize {
        self.height
    }

    /// Returns count of leafs in the tree
    pub fn leafs(&self) -> usize {
        self.leafs
    }

    /// next_pow2 returns next highest power of two from a given number if
    /// it is not already a power of two.
    ///
    /// http://locklessinc.com/articles/next_pow2/
    /// https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2/466242#466242
    fn next_pow2(mut n: usize) -> usize {
        debug_assert!(n > 1);
        n -= 1;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        n |= n >> 32;
        return n + 1;
    }
}
